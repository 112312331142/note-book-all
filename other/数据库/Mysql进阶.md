## 一、 存储引擎

### 1.1 MySQL体系结构

![](image\mysql\MySQL体系结构.png)

1. 连接层

   最上层是一些客户端和链接服务，包含本地sock通信和大多数基于客户端/服务端工具实现的类似于TCP/IP的通信。主要完成一些类似于连接处理、授权认证、及相关的安全方案。在该层上引入了线程池的概念，为通过认证安全接入的客户端提供线程。同样在该层上可以实现基于SSL的安全链接。服务器也会为安全接入的每个客户端验证它所具有的操作权限

2. 服务层

   第二层架构主要完成大多数的核心服务功能，如SQL接口，并完成缓存的查询，SQL的分析和优化，部分内置函数的执行。所有跨存储引擎的功能也在这一层实现，如 过程、函数等。在该层，服务器会解析查询并创建相应的内部解析树，并对其完成相应的优化如确定表的查询的顺序，是否利用索引等，最后生成相应的执行操作。如果是select语句，服务器还会查询内部的缓存，如果缓存空间足够大，这样在解决大量读操作的环境中能够很好的提升系统的性能。

3.  引擎层
   存储引擎层， 存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API和存储引擎进行通信。不同的存储引擎具有不同的功能，这样我们可以根据自己的需要，来选取合适的存储引擎。数据库中的索引是在存储引擎层实现的。

4. 存储层数据存储层， 主要是将数据(如: redolog、undolog、数据、索引、二进制日志、错误日志、查询日志、慢查询日志等)存储在文件系统之上，并完成与存储引擎的交互。

和其他数据库相比，MySQL有点与众不同，它的架构可以在多种不同场景中应用并发挥良好作用。主要体现在存储引擎上，插件式的存储引擎架构，将查询处理和其他的系统任务以及数据的存储提取分离。这种架构可以根据业务的需求和实际需要选择合适的存储引擎。

### 1.2 存储引擎介绍

存储引擎就是存储数据、建立索引、更新/查询数据等技术的实现方式 。

存储引擎是基于表的，而不是基于库的，所以存储引擎也可被称为表类型。

我们可以在创建表的时候，来指定选择的存储引擎，如果没有指定将自动选择默认的存储引擎。

1. 建表时指定存储引擎

   ```mysql
   create table 表名(
   	字段1	字段1类型	[comment 字段1注释],
       ......
       字段n	字段n类型	[comment 字段n注释],
   )engine = innodb [comment 表注释]
   ```

2.  查询当前数据库支持的搜索引擎

   ```mysql
   show engines;
   ```

### 1.3 存储引擎

#### 1.3.1 InnoDB

1.介绍

InnoDB是一种兼顾高可靠性和高性能性的通用存储引擎

2.特点

* DML操作遵循ACID模型，支持事务
* 行级锁，提高并发访问性能
* 支持外键foreign key约束，保证数据的完整性和正确性

3.文件

xxx..ibd:xxx代表的是表名，innoDB引擎的每张表都会对应这样一个表空间文件，存储该表的表结构（frm-早期的、sdi-新版的）、数据和索引

查看参数是否开启：

```mysql
show variables like 'innodb_file_per_table';
```

如果参数开启，代表对于InnoDB引擎的表，没一张表对应一个ibd文件

4.逻辑存储引擎

* 表空间：InnoDB存储引擎逻辑结构的最高层，ibd文件其实就是表空间文件，在表空间中可以包含多个Segment段
* 段：表空间是由各个段组成的，常见的段有数据段、索引段、回滚段等。InnoDB中对于段的管理，都是引擎自身完成的，不需要人为对其控制，一个段中包含多个区
* 区：区是表空间的单元结构，每个区的大小为1M，默认情况下，InnoDB存储引擎页的大小为16KB，即每一个区中一共有64个连续的页。
* 页：页是组成区的最小单元，页也是InnoDB存储引擎管理的最小单元，每个页的大小默认为16KB。为了保证页的连续性，InnoDB存储引擎每次从磁盘申请4-5个区
* 行：InnoDB是面向行的，也就是说数据是按行进行存放的，在每一行中除了定义表时所指定的字段外，还包含两个隐藏字段。

#### 1.3.2 MyISAM

1.介绍

MyISAM是MySQL早期的默认存储引擎

2.特点

* 不支持事务，不支持外键
* 支持表锁，不支持行锁
* 访问速度快

3.文件

* xxx.sdi：存储表结构信息
* xxx.MYD：存储数据
* xxx.MYI存储索引

#### 1.3.3 Memory

1.介绍

Memory引擎的表数据是存储在内存中的，由于受到硬件限制、或断电问题的影响，只能将这些表作为临时表或缓存使用

2.特点

* 内存存放
* hash索引（默认）

3.文件

xxx.sdi:存储表结构信息

1.3.4 区别即特点

| 特点         | InnoDB              | MyISAM | Memory |
| ------------ | ------------------- | ------ | ------ |
| 存储限制     | 64TB                | 有     | 有     |
| 事务安全     | 支持                | -      | -      |
| 锁机制       | 行锁                | 表锁   | 表锁   |
| B+tree索引   | 支持                | 支持   | 支持   |
| Hash索引     | -                   | -      | 支持   |
| 全文索引     | 支持（5.6版本之后） | 支持   | -      |
| 空间使用     | 高                  | 低     | N/A    |
| 内存使用     | 高                  | 低     | 中等   |
| 批量插入速度 | 低                  | 高     | 高     |
| 支持外键     | 支持                | -      | -      |

> InnoDB引擎和MyISAM引擎的区别
>
> * InnoDB引擎，支持事务，而MyISAM不支持
> * InnoDB引擎，支持行锁和表锁，而MyISAM仅支持表锁，不支持行锁
> * InnoDB引擎，支持外键，而MyISAM不支持

### 1.4 存储引擎选择

* InnoDB：是Mysql的默认存储引擎，支持事务、外键。如果应用对事务的完整性有比较高的要求，在并发条件下要求数据的一致性，数据操作除了插入和查询以外，还包含很多的更新、删除操作，那么InnoDB存储引擎是比较合适的选择
* MyISAM：如果应用的是以读操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完整性、并发性要求不是很高，那么选择这个引擎是非常合适的
* MEMORY：将所有数据保存在内存中，访问速度块，通常用于临时表及缓存。memory的缺陷是对表的大小有限制，太大的表无法缓存在内存中，而且无法保证数据的安全性



## 二、索引

### 2.1 索引概述

索引是帮助MySQL高效获取数据的数据结构（有序）。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些结构以某种方式引用数据，这样就可以在这些数据结构上实现高级查找算法，这种数据结构就是索引

* 无索引情况

  在无索引的情况下，就需要从第一行开始扫描，一直扫描到最后一行，这称之为全表扫描，性能很差

* 有索引情况

  如果针对一张表建立了索引，这个索引结构就是二叉树，会对一个字段建立了二叉树索引，那么在进行查询时，可以极大的提高查询的效率


特点：

| 优势                                                        | 劣势                                                         |
| ----------------------------------------------------------- | ------------------------------------------------------------ |
| 提高数据检索的效率，降低数据库的IO成本                      | 索引列也是要占用空间的                                       |
| 通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消耗 | 索引大大提高了查询效率，同时也降低更新表的速度，如对表进行insert，update，delete时，效率降低 |

### 2.2 索引结构

#### 2.2.1 概述

MySQL的索引是在存储引擎层实现的，不同的存储引擎有不同的索引结构

| 索引结构              | 描述                                                         |
| --------------------- | ------------------------------------------------------------ |
| B+Tree索引            | 最常见的索引类型，大部分引擎都支持B+树索引                   |
| Hash索引              | 底层数据结构使用哈希表实现的，只有精确匹配索引列的查询才有效，不支持范围查询 |
| R-tree（空间索引）    | 空间索引是MyISAM引擎的一个特殊索引结构，主要用于地理空间数据类型，通常使用较少 |
| Full-text（全文索引） | 是一种通过建立倒排索引，快速匹配文档的方式。类似于Lucene，Solr，ES |

不同存储引擎对索引结构的支持情况

| 索引       | InnoDB        | MyISAM | Memory |
| ---------- | ------------- | ------ | ------ |
| B+tree索引 | 支持          | 支持   | 支持   |
| Hash索引   | 不支持        | 不支持 | 支持   |
| R-tree索引 | 不支持        | 支持   | 不支持 |
| Full-text  | 5.6版本后支持 | 支持   | 不支持 |

> 我们平常说的索引，如果没有特别的指明，都是指B+树索引结构

#### 2.2.2 二叉树

> 参考**数据结构**

#### 2.2.3 B-Tree

B树是一种多叉路平衡查找树，相对于二叉树，B树每个节点可以有多个分支，即多叉，

以一颗最大度数（max-degree）为5的b-tree为例，那这个B树每个节点最多存储4个key，5个指针

![72414497364](image\mysql\B-树.png)

> 树的度数指的是一个节点的子节点个数

特点：

* 5阶的B树，每一个节点最多存储4个key，对应五个指针
* 一旦节点存储的key数量到达5，就会裂变，中间元素向上分裂
* 在B树中，非叶子节点和叶子节点都会存放数据

#### 2.2.4 B+Tree

B+树是B-树的变种

![72414514594](image\mysql\B+树.png)

绿色框中是索引部分，仅仅起到索引数据的作用，不存储数据

红色框中是数据存储部分，在其叶子节点中要存储具体的数据

B+树与B-树相比，主要有三点区别：

* 所有数据都会出现在一个叶子节点
* 叶子节点形成一个单向链表
* 非叶子节点仅仅起到所有数据的作用，具体的数据都是在叶子节点存放的

MySQL索引数据结构对经典的B+Tree进行了优化。在原B+Tree的基础上，增加一个指向相邻叶子节点的链表指针，就形成了带有顺序的B+Tree，提高区间访问的性能，利于排序

#### 2.2.5 Hash

哈希表就是采用一定的hash算法，将键值换算成新的hash值，映射到对应的槽位上，然后存储在你hash表中

如果两个（或多个）键值，映射到一个相同的槽位上，它们就产生了hash冲突（也称为hash碰撞），可以通过链表来解决

特点：

* Hash索引只能用于对等比较（=，in），不支持范围查询（between，>,<,...）
* 无法利用索引完成排序操作
* 查询效率高，通常（不存在hash冲突的情况）只需要一次检索就可以了，效率通常高于B+Tree索引

在MySQL中，支持hash索引的是Memory存储引擎，而InnoDB中具有自适应hash功能，hash索引是InnoDB存储引擎根据B+Tree索引表在指定的条件下自动创建的

>为什么InnoDB存储引擎选择使用B+Tree索引结构
>
>* 相对于二叉树，层级更少，搜索效率高
>* 对于B-Tree，无论是叶子节点还是非叶子节点，都会保存数据，这样导致一页中存储的键值减少，指针跟着减少，要同样保存大量数据，只能增加树的高度，导致性能降低
>* 相对于Hash索引，B+tree支持范围匹配及排序操作

### 2.3 索引分类

| 分类     | 含义                                                 | 特点                     | 关键字   |
| -------- | ---------------------------------------------------- | ------------------------ | -------- |
| 主键索引 | 针对于表中主键创建的索引                             | 默认自动创建，只能有一个 | primary  |
| 唯一索引 | 避免同一个表中某数据列中的值重复                     | 可以有多个               | unique   |
| 常规索引 | 快速定位特定数据                                     | 可以有多个               |          |
| 全文索引 | 全文索引查找的是文本中的关键词，而不是比较索引中的值 | 可以有多个               | fulltext |

在InnoDB存储引擎中，根据索引的存储形式，又可以分为两种:

| 分类                        | 含义                                                       | 特点                 |
| --------------------------- | ---------------------------------------------------------- | -------------------- |
| 聚集索引（Clustered Index） | 将数据存储和索引放到了一起，索引结构的叶子节点保存了行数据 | 必须有，而且只有一个 |
| 二级索引（Secondary Index） | 将数据与索引分开存储，索引结构的叶子节点关联的是对应的主键 | 可以存在多个         |

聚集索引选取规则：

* 如果存在主键，主键索引就是聚集索引
* 如果不存在主键，将使用第一个唯一的（UNIQUE）索引作为存储索引
* 如果表没有主键，或没有合适的唯一索引，则InnoDB会自动生成一个rowid作为隐藏的聚集索引

![72415189706](C:\下载的文件\笔记本\数据库\image\mysql\聚集索引和二级索引的具体结构.png)

具体过程如下：

1. 由于根据name字段进行查询，所以先根据name='Arm'到name字段的二级索引中进行匹配查找。但是在二级索引中只能查找到Arm对应的主键10
2. 由于查询返回的数据是*，所以此时，还需要根据主键值10，到聚集索引中查找10对应的记录，最终找到10对应的row
3. 最终拿到这行的数据，直接返回即可

> 回表查询：这种先到二级索引中查找数据，找到主键值，然后在到聚集索引中根据主键值，获取数据的方式，就称之为回表查询

### 2.4 索引语法

1. 创建索引

   ```mysql
   create [unique|fulltext] index index_name on table_name (index_col_name,...)
   ```

2. 查看索引

   ```mysql
   show index from table_name
   ```

3. 删除索引

   ```mysql
   drop index index_name on table_name
   ```

### 2.5 SQL性能分析

#### 2.5.1 SQL执行频率

MySQL客户端连接后，同过下方指令可以提供服务器状态信息，其中可以查看当前数据库的insert、update、delete、select的频率

```mysql
-- session 是查看当前会话
-- global  是查询全局数据
show global status like 'com____';
```

通过上述指令，我们可以查看到当前数据库是否以查询为主，还是以增删改为主，从而为数据库优化提供参考依据。如果以增删改为主，可以不考虑对其进行索引优化；如果是以查询为主，那么就要考虑对数据库的索引进行优化

#### 2.5.2 慢查询日志

慢查询日志记录了所有执行时间超过指定参数（long_query_time，单位：秒，默认：10秒）的所有SQL语句

查看系统变量slow_query_log

```mysql
show variables like 'slow_query_log'
```

通过慢查询日志，就可以定位出执行效率比较低的SQL，从而有争对的进行优化

#### 2.5.3 profile详情

show profiles能够在做SQL优化时帮助我们了解时间的耗费情况

通过have_profilling参数，能够看到当前MySQL是否支持profile操作

```mysql
select @@have_profiling;
```

通过set语句在session/global级别开启profiling

```mysql
set profiling = 1;
```

执行一系列的业务SQL操作，然后通过如下指令查看指令的执行耗时：

```mysql
-- 查看每一条SQL的耗时情况
show profile;
-- 查看指定query_id的SQL语句各个阶段的耗时情况
show profile for query query_id;
-- 查看指定的query_id的SQL语句CPU的执行情况
show profile cpu for query query_id
```

#### 2.5.4 explain

explain或者desc命令获取MySQL如何执行select语句的信息，包括select语句执行的过程中表如何连接和连接的顺序

语法：

```mysql
-- 查看在select语句之前加上关键字explain/desc
explain select 字段列表 from 表名 where 条件;
```

explain执行计划中各个字段的含义：

| 字段         | 含义                                                         |
| ------------ | ------------------------------------------------------------ |
| id           | select查询的序列号，表示查询中执行select子句或者是操作表的顺序（id相同，执行顺序从上到下；id不同，值越大，越先执行） |
| select_type  | 表示select的类型，常见的取值有simple（简单表，即不接受表连接或者子查询）、primary（主查询，即外层的查询）、union（union中的第二个或者后面的查询语句）、subquery（select/where之后包含了子查询）等 |
| type         | 表示连接类型，性能由好到差的连接类型为null、system、const、eq_ref、ref、range、index、all |
| possible_key | 显示可能应用在这张表的索引，一个或多个                       |
| key          | 实际使用的索引，如果为null，则没有使用索引                   |
| key_len      | 表示索引中使用的字节数，该值为索引字段最大可能长度，并非实际使用长度，在不损失精确性的前提下，长度越短越好 |
| rows         | MySQL认为要执行查询的行数，在innoDB引擎的表中是一个估计值，不一定准确 |
| filtered     | 表示返回结果的行数占需读取行数的百分比，fiitered的值越大越好 |

### 2.6 索引使用

#### 2.6.1 最左前缀法则

如果索引了多列（联合索引），要遵循最左前缀法则。最左前缀法则指的是查询从索引的最左列开始，并且不跳过索引中的列。如果跳跃某一列，索引将部分失效（后面的字段也将失效）

例如：

在user表中，有一个联合索引，这个联合索引设计三个字段，顺序分别为：profession，age，status；对于做前缀法则指的是，查询时，最左边的列，也就是profession必须存在，否则索引全部失效；并且不能跳过某一列，否则该列后面的字段索引将失效

> 在执行SQL语句：
>
> ```mysql
> explain select * from user where age =31 and status = '0' and profession = '软件工程'
> ```
>
> 满足最左前缀法则，联合索引是生效的
>
> 注：最左前缀法则中指得是最左边的列，是在指查询时，联合索引的最左边的字段（即是第一个字段）必须存在，在编写SQL时，条件编写的先后顺序无关

#### 2.6.2 范围查询

联合索引中，出现范围查询（>,<）,范围查询右侧的列索引失效

在业务范围允许的情况下，尽可能的使用类似于>=或<=这类的范围查询，而避免使用>或<

#### 2.6.3 索引失效情况

1. 不要在索引上进行运算操作，索引将失效

   例如进行一些函数运算操作subString()、trim()等

2. 字符串类型字段使用时，不加引号，索引将失效

   如果字符串不加单引号，对于查询结果，没什么影响，但是数据库存在隐式类型转换，索引将失效

3. 如果仅仅是尾部模糊匹配，索引将不会失效，但如果是头部模糊匹配，索引失效

   在like模糊匹配中，在关键字后面加%，索引会生效；在关键字前面加%，索引会失去效果

4. 用or分割开的条件，如果or前的条件中的列有索引，而后面的列中没有索引，那么涉及的索引都不会被用到

   只有当or连接的条件，左右两侧字段都有索引时，索引才会生效

5. 如果Mysql评估使用索引比全表慢，则不使用索引

#### 2.6.4 SQL提示

是优化数据库的一个重要的，简单来说就是，在SQL语句加上一些人为的提示来达到优化操作的目的

1. use index(索引)：建议MySQL使用哪一个索引来完成此次查询（仅仅是建议，mysql内部还会再次进行评估）
2. ignore index(索引)：忽略指定索引
3. force index(索引)：强制使用索引

#### 2.6.5 覆盖索引

覆盖索引是指查询使用了索引，并且需要返回的列，在该索引中已经全部能够找到

explain执行计划中最后一个字段extra的含义：

| Extra                   | 含义                                                         |
| ----------------------- | ------------------------------------------------------------ |
| Using where;Using Index | 查找使用了索引，但是需要的数据都在索引列中能找到，所以不需要回表查询数据 |
| Using index condition   | 查找使用了索引，但是需要回表查询数据                         |

如果一个联合索引中关联了三个字段：profession、age、status，而这个索引也是一个二级索引，所以叶子节点下面挂的是这一行的主键id。所以我们查询的数据在id、profession、age、status之中时，则直接走二级索引返回数据。但是如果超出这个范围，就需要拿到主键id，在去扫描聚集索引，再获取额外的数据，就是回表。

如果我们一直使用select *，查询返回所有字段值，很容易就造成回表查询（除非是根据主键查询，此时只会扫描聚集索引）

#### 2.6.6. 前缀索引

当字符段类型为字符串（varchar、text、longtext等）时，有时候需要索引很长的字符串，这会让索引变得很大，查询时，浪费大量的磁盘IO。此时可以只将字符串中的一部分前缀，建立索引，这样可以大大节约索引空间，从而提高索引效率

语法：

```mysql
create index idx_xxxx on table_name(column(n));
```

可以根据索引的选择性来决定，而选择性是指不重复的索引值（基数）和数据表的记录总数的比值，索引的选择性越高则查询效率越高

唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的

```mysql
select count(distinct email) /count(*) from tb_user
select count(distinct substring(email,1,5)) /count(*) from tb_user
```

#### 2.6.7 单列索引和联合索引

单列索引：即一个索引只包含单个列

聚集索引：即一个索引包含了多个列

> 在业务场景中，如果存在多个查询条件，考虑针对于查询字段建立索引时，建议建立联合索引，而非单列索引

### 2.7 索引设计原则

1). 针对于数据量较大，且查询比较频繁的表建立索引。

2). 针对于常作为查询条件（where）、排序（order by）、分组（group by）操作的字段建立索

引。

3). 尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高。

4). 如果是字符串类型的字段，字段的长度较长，可以针对于字段的特点，建立前缀索引。

5). 尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，

避免回表，提高查询效率。

6). 要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价也就越大，会影响增

删改的效率。

7). 如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它。当优化器知道每列是否包含

NULL值时，它可以更好地确定哪个索引最有效地用于查询。



## 三、SQL优化

### 3.1 插入数据

#### 3.1.1 insert

如果我们需要一次性往数据库中插入多条记录，可以有三个方面进行优化：

```mysql
insert into tb_test values(1,'tom');
insert into tb_test values(2,'cat');
insert into tb_test values(3,'jerry');
```

1. 批量插入数据

   ```mysql
   Insert into tb_test values(1,'Tom'),(2,'Cat'),(3,'Jerry');
   ```

2. 手动控制事务

   ```mysql
   start transaction;
   insert into tb_test values(1,'Tom'),(2,'Cat'),(3,'Jerry');
   insert into tb_test values(4,'Tom'),(5,'Cat'),(6,'Jerry');
   insert into tb_test values(7,'Tom'),(8,'Cat'),(9,'Jerry');
   commit;
   ```

3. 主键顺序插入，性能要高于乱序插入

   ```mysql
   主键乱序插入 : 8 1 9 21 88 2 4 15 89 5 7 3
   主键顺序插入 : 1 2 3 4 5 7 8 9 15 21 88 89
   ```

#### 3.1.2 大批量插入数据

如果一次性需要插入大批量数据(比如: 几百万的记录)，使用insert语句插入性能较低，此时可以使用MySQL数据库提供的load指令进行插入。

可以执行如下指令，将数据脚本文件中的数据加载到表结构中：

```mysql
-- 客户端连接服务端时，加上参数 -–local-infile
mysql –-local-infile -u root -p

-- 设置全局参数local_infile为1，开启从本地加载文件导入数据的开关
set global local_infile = 1;

-- 执行load指令将准备好的数据，加载到表结构中
load data local infile '/root/sql1.log' into table tb_user fields
terminated by ',' lines terminated by '\n' ;
```

### 3.2 主键优化

1. 数据组织方式

   在InnoDB存储引擎中，表数据都是根据主键顺序组织存放的，这种存储方式的表称为索引组织表

   行数据都是存储在聚集索引的叶子节点上的

   在InnoDB引擎中，数据行是记录在逻辑结构 page 页中的，而每一个页的大小是固定的，默认16K。那也就意味着， 一个页中所存储的行也是有限的，如果插入的数据行row在该页存储不小，将会存储到下一个页中，页与页之间会通过**指针**连接。

2. 页分裂和页合并

3. 索引设计原则

   * 满足业务需求的情况下，尽量降低主键的长度。
   *  插入数据时，尽量选择顺序插入，选择使用AUTO_INCREMENT自增主键。
   * 尽量不要使用UUID做主键或者是其他自然主键，如身份证号。
   * 业务操作时，避免对主键的修改。

### 3.3 order by优化

order by优化原则:

* 根据排序字段建立合适的索引，多字段排序时，也遵循最左前缀法则。
* 尽量使用覆盖索引。
* 多字段排序, 一个升序一个降序，此时需要注意联合索引在创建时的规则（ASC/DESC）。
* 如果不可避免的出现filesort，大数据量排序时，可以适当增大排序缓冲区大小

sort_buffer_size(默认256k)。

### 3.4 group by优化

在分组操作中，我们需要通过以下两点进行优化，以提升性能：

A. 在分组操作时，可以通过索引来提高效率。

B. 分组操作时，索引的使用也是满足最左前缀法则的

### 3.5 limit优化

在数据量比较大时，如果进行limit分页查询，在查询时，越往后，分页查询效率越低。 

优化思路: 一般分页查询时，通过创建 覆盖索引 能够比较好地提高性能，可以通过覆盖索引加子查询形式进行优化

### 3.6 count优化

#### 3.6.1 概念

如果数据量很大，在执行count操作时，是非常耗时的。

* MyISAM 引擎把一个表的总行数存在了磁盘上，因此执行 count(*) 的时候会直接返回这个数，效率很高； 但是如果是带条件的count，MyISAM也慢。
* InnoDB 引擎就麻烦了，它执行 count(*) 的时候，需要把数据一行一行地从引擎里面读出来，然后累积计数。

如果说要大幅度提升InnoDB表的count效率，主要的优化思路：自己计数(可以借助于redis这样的数据库进行,但是如果是带条件的count又比较麻烦了)。

#### 3.6.2 count用法

count()是一个聚合函数，对于返回的结果集，一行行的判断，如果count函数的参数不是null，累计值就加一，否则不加，最后返回累计值

| count用法   | 含义                                                         |
| ----------- | ------------------------------------------------------------ |
| count(主键) | InnoDB引擎会遍历在整张表，把每一行的主键id值都取出来，返回给服务层。服务层拿到主键后，直接按行进行累加（主键不能为null） |
| count(字段) | 没有not null约束：InnoDB引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，服务层判断是否为null，不为null，计数累加<br>有not null约束：InnoDB引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，直接按行进行累加 |
| count(数字) | InnoDB引擎遍历整张表，但不取值。服务层对于返回的每一行，放一个数字“1”进去，直接按行进行累加 |
| count(*)    | InnoDB引擎并不会把全部字段取出来，而是专门做了优化，不取值，服务层直接按行进行累加 |

>按效率排序的话，count(字段)<count(主键id)<count(1)≈count(* ), 所以尽可能使用count(*)

### 3.7 update优化

```mysql
update course set name = 'SpringBoot' where name = 'PHP';
```

当我们开启多个事务，在执行上述的SQL时，我们发现行锁升级为了表锁，导致update语句的性能大大降低

> InnoDB的行锁是针对索引加的锁，不是针对记录加的锁，并且该索引不能失效，否则会从行锁升级为表锁



## 四、 视图

### 4.1 介绍

视图（View）是一种虚拟存在的表。视图中的数据并不在数据库中实际存在，行和列数据来自定义视

图的查询中使用的表，并且是在使用视图时动态生成的。

通俗的讲，视图只保存了查询的SQL逻辑，不保存查询结果。所以我们在创建视图的时候，主要的工作

就落在创建这条SQL查询语句上。

### 4.2 语法

1. 创建

   ```mysql
   create [or replace] view 视图名称[(列名列表)] as select语句 [with[cascaded | local ] check option]
   ```

2. 查询

   查看创建视图的语句：

   ```mysql
   show create view 视图名称;
   ```

   查看视图数据：

   ```mysql
   select * from 视图名称......;
   ```

3. 修改

   ```mysql
   create [or replace] view 视图名称[(列名列表)] as select语句 [with [cascaded |local ] check option]
   ```

   ```mysql
   alter view 视图名称[(列名列表)] as select语句 [with [cascaded |local ] check option]
   ```

4. 删除

   ```mysql
   drop view [if exists] 视图名称 [,视图名称] ...
   ```

演示实例：

```mysql
-- 创建视图
create or replace view stu_v_1 as select id,name from student where id <= 10;
-- 查询视图
show create view stu_v_1;
select * from stu_v_1;
select * from stu_v_1 where id < 3;
-- 修改视图
create or replace view stu_v_1 as select id,name,no from student where id <= 10;
alter view stu_v_1 as select id,name from student where id <= 10;
-- 删除视图
drop view if exists stu_v_1;
```

### 4.3 检查选项

当使用WITH CHECK OPTION子句创建视图时，MySQL会通过视图检查正在更改的每个行，例如 插入，更新，删除，以使其符合视图的定义。 

MySQL允许基于另一个视图创建视图，它还会检查依赖视图中的规则以保持一致性。为了确定检查的范围mysql提供了两个选项： CASCADED 和 LOCAL，默认值为 CASCADED 

1. cascade（级联）

   比如v2视图是基于v1视图的，如果在v2视图创建的时候指定了检查选项为cascaded，但是v1视图创建时未指定检查选项。则在执行检查时，不仅会检查v2，还回级联检查v2的关联试图v1

2. local（本地）

   比如v2视图是基于v1视图的，如果在v2视图创建的时候指定了检查选项为local，但是v1视图创建时未指定检查选项。则在执行检查时，只会检查v2，不会检查v2的关联试图v1

### 4.4 视图的更新

要使视图可更新，视图中的行与基础表中的行之间必须存在一对一的关系。如果视图包含以下任何一

项，则该视图不可更新：

*  聚合函数或窗口函数（SUM()、 MIN()、 MAX()、 COUNT()等）
* DISTINCT
* GROUP BY
* HAVING
* UNION 或者 UNION ALL

示例演示：

```mysql
create view stu_v_count as select count(*) from student; 
```

上述的视图中，就只有一个单行单列的数据，如果我们对这个视图进行更新或插入的，将会报错。

### 4.5 视图的作用

1). 简单

视图不仅可以简化用户对数据的理解，也可以简化他们的操作。那些被经常使用的查询可以被定义为视图，从而使得用户不必为以后的操作每次指定全部的条件。

2). 安全

数据库可以授权，但不能授权到数据库特定行和特定的列上。通过视图用户只能查询和修改他们所能见到的数据

3). 数据独立

视图可帮助用户屏蔽真实表结构变化带来的影响。

## 五、存储过程

### 5.1 介绍

存储过程是事先经过编译并存储在数据库中的一段 SQL 语句的集合，调用存储过程可以简化应用开发人员的很多工作，减少数据在数据库和应用服务器之间的传输，对于提高数据处理的效率是有好处的。存储过程思想上很简单，就是数据库 SQL 语言层面的代码封装与重用。

* 封装，复用 -----------------------> 可以把某一业务SQL封装在存储过程中，需要用到的时候直接调用即可。
* 可以接收参数，也可以返回数据 --------> 再存储过程中，可以传递参数，也可以接收返回值。
* 减少网络交互，效率提升 -------------> 如果涉及到多条SQL，每执行一次都是一次网络传输。 而如果封装在存储过程中，我们只需要网络交互一次可能就可以了。

### 5.2 基本语法

* 创建

  ```mysql
  create procedure 存储过程名称 ([参数列表])
  begin
  	-- SQL语句
  end;
  ```

* 调用

  ```mysql
  call 名称 ([参数])
  ```

* 查看

  ```mysql
  select * from information_schema.routines where routine_schema = 'xxx';-- 查询指定数据库的存储过程及状态信息
  show create procedure 存储过程名称; -- 查询某个存储存储过程的定义
  ```

* 删除

  ```mysql
  drop procedure [if exists] 存储过程名称
  ```

注：在命令行中，执行创建过程的SQL时，需要通过关键字delimiter指定SQL语句的结束符

演示示例:

```mysql
-- 存储过程基本语法
-- 创建
create procedure p1()
begin
select count(*) from student;
end;

-- 调用
call p1();

-- 查看
select * from information_schema.ROUTINES where ROUTINE_SCHEMA = 'itcast';
show create procedure p1;

-- 删除
drop procedure if exists p1;
```

### 5.3 变量

在MySQL中变量分为三种类型：系统变量、用户自定义变量、局部变量

#### 5.3.1 系统变量

系统变量是MySQL服务器提供，不是用户定义的，属于服务器层面，分为全局变量（global）、会话变量（session）

* 全局变量：全局变量针对于所有的会话
* 会话变量：会话变量针对于单个会话，在另外一个会话窗口就不生效

mysql服务重新启动之后，所设置的全局参数会失效，要想不失效，可以在 /etc/my.cnf 中配置。

1. 查看系统变量：

   ```mysql
   SHOW [ SESSION | GLOBAL ] VARIABLES ; -- 查看所有系统变量
   SHOW [ SESSION | GLOBAL ] VARIABLES LIKE '......'; -- 可以通过LIKE模糊匹配方式查找变量
   SELECT @@[SESSION | GLOBAL] 系统变量名; -- 查看指定变量的值
   ```

2. 设置系统变量

   ```mysql
   set [session | global] 系统变量 = 值;
   set @@[session | global] 系统变量名;
   ```

注意：如果没有指定session/global,默认是session，会话变量

#### 5.3.2 用户定义变量

用户定义变量是用户根据需要自己定义的变量，用户变量不用提前声明，在用的时候直接用"@变量名"使用就可以，其作用域为当前链接

1. 赋值

   方式一：

   ```mysql
   set @var_name = expr [,@var_name =expr] ... ;
   ```

   赋值时，可以使用 = ，也可以使用 :=

   方式二：

   ```mysql 
   select 字段名 into @var_name from 表名;
   ```

2. 使用

   ```mysql
   select @var_name;
   ```

   用户定义的变量无需对其进行声明或初始化，只不过获取到的值为null

#### 5.3.3 局部变量

局部变量是根据需要定义的在局部生效的变量，访问之前，需要declare声明，可用作存储过程内的局部变量和输入参数，局部变量的范围是在其内声明的begin . . . end块

1. 声明

   ```mysql
   declare 变量名 变量类型 [default ... ]
   ```

   变量类型就是数据段的类型：int、bigint、char、varchar、date、time等

2. 赋值

   ```mysql
   set 变量名 = 值
   set 变量名 := 值
   select 字段名 into 变量名 from 表名 ... ;
   ```

演示实例：

```mysql
-- 声明局部变量 - declare
-- 赋值
create procedure p2()
begin
	declare stu_count int default 0;
	select count(*) into stu_count from student;
	select stu_count;
end;

call p2();
```

### 5.4 if

if用于做条件判断，具体语法为：

```mysql
IF 条件1 THEN
	.....
ELSEIF 条件2 THEN -- 可选
	.....
ELSE -- 可选
	.....
END IF;
```

在if条件判断的结构中，ELSE IF 结构可以有多个，也可以没有。 ELSE结构可以有，也可以没有

### 5.5 参数

参数的类型可以分为三种：in、out、inout，具体含义如下：

| 类型  | 含义                                               | 备注 |
| ----- | -------------------------------------------------- | ---- |
| in    | 该类参数作为输入，也就是需要调用参数时传入值       | 默认 |
| out   | 该类参数作为输出，也就是需要调用参数可以作为返回值 |      |
| inout | 既可以作为输入参数，也可以作为输出参数             |      |

用法：

```mysql
CREATE PROCEDURE 存储过程名称 ([ IN/OUT/INOUT 参数名 参数类型 ])
BEGIN
-- SQL语句
END ;
```

### 5.6 case

case结构及作用，与流程控制函数很类似

语法1：

```mysql
-- 含义： 当case_value的值为 when_value1时，执行statement_list1，当值为 when_value2时，执行statement_list2， 否则就执行 statement_list
CASE case_value
	WHEN when_value1 THEN statement_list1
	[ WHEN when_value2 THEN statement_list2] ...
	[ ELSE statement_list ]
END CASE;
```

语法2：

```mysql
-- 含义： 当条件search_condition1成立时，执行statement_list1，当条件search_condition2成
立时，执行statement_list2， 否则就执行 statement_list
CASE
	WHEN search_condition1 THEN statement_list1
	[WHEN search_condition2 THEN statement_list2] ...
	[ELSE statement_list]
END CASE;
```

### 5.7 while

while循环是有条件的循环控制语句，满足条件后，在执行循环体中的SQL语句

语法：

```mysql
while 条件 do
	SQL逻辑...
end while;
```

### 5.8 repeat

repeat是有条件的循环控制语句，当满足until声明的条件时，则退出循环

具体语法：

```mysql
repeat 
	SQL逻辑
	until 条件
end repeat;
```

### 5.9 loop

loop实现简单的循环，如果不在SQL逻辑中增加退出循环的条件，可以用其来实现简单的死循环，loop可以配合leave、iterate使用

leave：配合循环使用，退出循环

iterate：必须用在循环中，作用是跳过当前循环剩下的语句，直接进入下一次循环

```mysql
[begin_label] loop
	SQL逻辑
end loop [end_label]

leave label;
iterate lable;
```

案例：计算从1到n之间的偶数累加的值，n为传入的参数值

```mysql
-- A. 定义局部变量, 记录累加之后的值;
-- B. 每循环一次, 就会对n进行-1 , 如果n减到0, 则退出循环 ----> leave xx
-- C. 如果当次累加的数据是奇数, 则直接进入下一次循环. --------> iterate xx

create procedure p10(in n int)
begin
	declare total int default 0;
	sum:loop
		if n<=0 then
			leave sum;
		end if;
		
		if n%2 = 1 then
			set n := n - 1;
			iterate sum;
		end if;

		set total := total + n;
		set n := n - 1;
	end loop sum;
	select total;
end;

call p10(100);
```

### 5.10 游标

游标（cursor）是用来存储查询结果集的数据类型，在存储过程和函数中可以使用游标对结果集进行循环的处理。

游标的使用：

* 声明游标：`declare 游标名称 cursor for 查询语句;`
* 打开游标：`open 游标名称;`
* 获取游标记录：`fetch 游标名称 into 变量 [,变量];`
* 关闭游标：`close 游标名称`

### 5.11 条件处理程序

条件处理程序（Handler）可以用来定义在流程控制结构执行过程中遇到问题时相应的处理步骤

具体语法：

```mysql
DECLARE handler_action HANDLER FOR condition_value [, condition_value] ... statement ;

handler_action 的取值：
	CONTINUE: 继续执行当前程序
	EXIT: 终止执行当前程序

condition_value 的取值：
	SQLSTATE sqlstate_value: 状态码，如 02000
	SQLWARNING: 所有以01开头的SQLSTATE代码的简写
	NOT FOUND: 所有以02开头的SQLSTATE代码的简写
	SQLEXCEPTION: 所有没有被SQLWARNING 或 NOT FOUND捕获的SQLSTATE代码的简写
```

### 5.12 存储函数

存储函数是有返回值的存储过程，存储函数的参数只能是in类型的

```mysql
CREATE FUNCTION 存储函数名称 ([ 参数列表 ])
RETURNS type [characteristic ...]
BEGIN
	-- SQL语句
	RETURN ...;
END ;
```

characteristic说明：

* deterministic：相同的输入参数总是产生相同的结果
* no sql：不包含sql语句
* reads sql data：包含读取数据的语句，但不包含写入数据的语句

## 六、触发器

### 6.1 介绍

触发器是与表有关的数据库对象，指在insert/update/delete之前(BEFORE)或之后(AFTER)，触发并执行触发器中定义的SQL语句集合。触发器的这种特性可以协助应用在数据库端确保数据的完整性, 日志记录 , 数据校验等操作。

使用别名OLD和NEW来引用触发器中发生变化的记录内容，这与其他的数据库是相似的。现在触发器还只支持行级触发，不支持语句级触发。

| 触发器类型     | new和old                                             |
| -------------- | ---------------------------------------------------- |
| insert型触发器 | new表示将要或者已经新增的语句                        |
| update型触发器 | old表示修改之前的数据，new表示将要或已经修改后的数据 |
| delete型触发器 | old表示将要或者已经删除的数据                        |

### 6.2 语法

* 创建

  ```mysql
  create trigger trigger_name
  before/after insert/update/delete
  on tbl_name for each row -- 行级触发器
  begin
  	trigger_simt;
  end;
  ```

* 查看

  ```mysql
  show triggers;
  ```

* 删除

  ```mysql
  drop trigger [schema_name.]trigger_name; -- 如果没有指定schema_name，默认为当前数据库
  ```



## 七、锁

锁是计算机协调多个进程或线程并发访问某一资源的机制。

在数据库中，除传统的计算资源（CPU、RAM、I/O）的争用以外，数据也是一种供许多用户共享的资源。

如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。

MySQL中的锁，按照锁的粒度分，分为以下三类：

全局锁：锁定数据库中的所有表。

表级锁：每次操作锁住整张表。

行级锁：每次操作锁住对应的行数据。

### 7.1 全局锁

全局锁就是对整个数据库实例加锁，加锁后整个实例就处于只读状态，后续的DML语句，DDL语句，已经更新操作的事务提交语句都将被阻塞

其典型的使用场景：做全库的逻辑备份，对所有的表进行锁定，从而获取一致性视图，保证数据的完整性

语法：

* 加全局锁：`flush tables with read lock;`
* 数据备份：`mysqldump -uroot -p1234 itcast > itcast.sql;`
* 释放锁：`unlock tables;`

数据库中加全局锁，是一个比较重的操作，存在以下问题：

* 如果在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆
* 如果在从库上备份，那么在备份期间从库不能执行主库同步过来的二进制文件（binlog），会导致主从延迟

### 7.2 表级锁

表级锁，每次操作锁住整张表，锁定粒度大，发生锁冲突的概率最高，并发度最低。应用在MyISAM、InnoDB、BDB等存储引擎中

表级锁的分类：

* 表锁
* 元数据锁（meta data lock，MDL）
* 意向锁

#### 7.2.1 表锁

表锁分为两类：

* 表共享读锁
* 表独占写锁

语法：

* 加锁：`lock table 表名... read/write`
* 释放锁：`unlock tables` /` 客户端断开连接`

> 读锁不会阻塞其他客户端的读，但是会阻塞写。写锁既会阻塞其他客户端的读，又会阻塞其他客户端的写。

#### 7.2.2. 元数据锁（MDL）

MDL加锁过程是系统自动控制，无需显式使用，在访问一张表的时候会自动加上。

MDL锁主要作用是维护表**元数据**的数据一致性，在表上有活动事务的时候，不可以对元数据进行写入操作，为了避免DML与DDL冲突，保证读写的正确性

这里的**元数据**，可以简单理解为就是一张表的结构，也就是说，某一张表涉及到未提交的事务时，是不能够修改这张表的表结构的

当对一张表进行增删改查的时候，加MDL读锁（共享）；当对表结构进行变更操作时，加MDL写锁（排他）

常见的SQL操作时，所添加的元数据锁：

| 对应SQL                                        | 锁类型                                | 说明                                             |
| ---------------------------------------------- | ------------------------------------- | ------------------------------------------------ |
| lock tables xxx read/write                     | shared_read_only/shared_no_read_write |                                                  |
| select 、select ... lock in share mode         | shared_read                           | 与shared_read、shared_write兼容、与exclusive互斥 |
| insert 、update、delete、select ... for update | shared_write                          | 与shared_read、shared_write兼容、与exclusive互斥 |
| alter table ...                                | exclusive                             | 与其他MDL都互斥                                  |

* 当执行SELECT、INSERT、UPDATE、DELETE等语句时，添加的是元数据共享锁（SHARED_READ/ SHARED_WRITE ），之间是兼容的。
* 当执行SELECT语句时，添加的是元数据共享锁（SHARED_READ），会阻塞元数据排他锁（EXCLUSIVE），之间是互斥的。

#### 7.2.3 意向锁

为了避免DML在执行时，加的行锁与表锁的冲突，在InnoDB中引入了意向锁，使得表锁不用检查每行数据是否加锁，使得意向锁来减少表锁的检查

意向锁的作用：在客户端执行DML操作时，会对涉及的行进行加锁，同时也会对该表加上意向锁，而其他客户端在对这张表加表锁的时候会根据该表上所加的意向锁来判定是否可以成功加表锁，而不用逐行判断行锁情况了

分类：

* 意向共享锁(IS): 由语句select ... lock in share mode添加 。 与 表锁共享锁(read)兼容，与表锁排他锁(write)互斥。
* 意向排他锁(IX): 由insert、update、delete、select...for update添加 。与表锁共享锁(read)及排他锁(write)都互斥，意向锁之间不会互斥。

> 一旦事务提交，意向共享锁、意向排他锁，都会自动释放

### 7.3 行级锁

行级锁，每次操作锁住对应的行数据。锁定粒度最小，发生锁冲突的概率最低，并发度最高。应用在InnoDB存储引擎中。

InnoDB的数据是基于索引组织的，行锁是通过对索引上的索引项加锁来实现的，而不是对记录加的锁。对于行级锁，主要分为以下三类：

* 行锁（Record Lock）：锁定单个行记录的锁，防止其他事务对此行进行update和delete。在RC、RR隔离级别下都支持。
* 间隙锁（Gap Lock）：锁定索引记录间隙（不含该记录），确保索引记录间隙不变，防止其他事务在这个间隙进行insert，产生幻读。在RR隔离级别下都支持。
* 临键锁（Next-Key Lock）：行锁和间隙锁组合，同时锁住数据，并锁住数据前面的间隙Gap。在RR隔离级别下支持。

#### 7.3.1 行锁

InnoDB实现了以下两种类型的行锁：

* 共享锁（S）：允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁
* 排他锁（X）：允许获取排他锁的事务更新数据，阻止其他事务获得相同数据集的共享锁和排他锁

两种行锁的兼容情况：

|      | S    | X    |
| ---- | ---- | ---- |
| S    | 兼容 | 冲突 |
| X    | 冲突 | 冲突 |

常见的SQL语句，在执行时，所加的行锁如下：

| SQL                           | 行所类型   | 说明                                     |
| ----------------------------- | ---------- | ---------------------------------------- |
| insert ...                    | 排他锁     | 自动加锁                                 |
| update ...                    | 排他锁     | 自动加锁                                 |
| delete ...                    | 排他锁     | 自动加锁                                 |
| select （正常）               | 不加任何锁 |                                          |
| select ... lock in share mode | 共享锁     | 需要手动在select之后加lock in share mode |
| select ... for update         | 排他锁     | 需要手动在select之后加for update         |

默认情况下，InnoDB在 REPEATABLE READ事务隔离级别运行，InnoDB使用 next-key 锁进行搜索和索引扫描，以防止幻读。

* 针对唯一索引进行检索时，对已存在的记录进行等值匹配时，将会自动优化为行锁。
* InnoDB的行锁是针对于索引加的锁，不通过索引条件检索数据，那么InnoDB将对表中的所有记录加锁，此时 就会升级为表锁。

#### 7.3.2 间隙锁&临界锁

默认情况下，InnoDB在 REPEATABLE READ事务隔离级别运行，InnoDB使用 next-key 锁进行搜索和索引扫描，以防止幻读。

* 索引上的等值查询(唯一索引)，给不存在的记录加锁时, 优化为间隙锁 。
* 索引上的等值查询(非唯一普通索引)，向右遍历时最后一个值不满足查询需求时，next-keylock 退化为间隙锁。
* 索引上的范围查询(唯一索引)--会访问到不满足条件的第一个值为止。

	 注：间隙锁的唯一目的是防止其他事务插入间隙。间隙锁可以共存，一个事务采用的间隙锁不会阻止另一个		       事务在同一间隙上采用间隙锁

## 八、InnoDB引擎

### 8.1 架构

MySQL5.5 版本开始，默认使用InnoDB存储引擎，它擅长事务处理，具有崩溃恢复特性，在日常开发中使用非常广泛。下面是InnoDB架构图，左侧为内存结构，右侧为磁盘结构。![nnoDB架构](image\mysql\InnoDB架构图.png)

#### 8.1.1 内存结构

在左侧的内存结构中，主要分为这么四大块儿： Buffer Pool、Change Buffer、Adaptive Hash Index、Log Buffer。 

1. Buffer Pool

InnoDB存储引擎基于磁盘文件存储，访问物理硬盘和在内存中进行访问，速度相差很大，为了尽可能弥补这两者之间的I/O效率的差值，就需要把经常使用的数据加载到缓冲池中，避免每次访问都进行磁盘I/O。

在InnoDB的缓冲池中不仅缓存了索引页和数据页，还包含了undo页、插入缓存、自适应哈希索引以及InnoDB的锁信息等等。

缓冲池 Buffer Pool，是主内存中的一个区域，里面可以缓存磁盘上经常操作的真实数据，在执行增删改查操作时，先操作缓冲池中的数据（若缓冲池没有数据，则从磁盘加载并缓存），然后再以一定频率刷新到磁盘，从而减少磁盘IO，加快处理速度。

缓冲池以Page页为单位，底层采用链表数据结构管理Page。根据状态，将Page分为三种类型：

• free page：空闲page，未被使用。

• clean page：被使用page，数据没有被修改过。

• dirty page：脏页，被使用page，数据被修改过，也中数据与磁盘的数据产生了不一致

2. Change Buffer

Change Buffer，更改缓冲区（针对于非唯一二级索引页），在执行DML语句时，如果这些数据Page没有在Buffer Pool中，不会直接操作磁盘，而会将数据变更存在更改缓冲区 Change Buffer中，在未来数据被读取时，再将数据合并恢复到Buffer Pool中，再将合并后的数据刷新到磁盘中。

3. Adaptive Hash Index

自适应hash索引，用于优化对Buffer Pool数据的查询。MySQL的innoDB引擎中虽然没有直接支持hash索引，但是给我们提供了一个功能就是这个自适应hash索引。因为前面我们讲到过，hash索引在进行等值匹配时，一般性能是要高于B+树的，因为hash索引一般只需要一次IO即可，而B+树，可能需要几次匹配，所以hash索引的效率要高，但是hash索引又不适合做范围查询、模糊匹配等。

InnoDB存储引擎会监控对表上各索引页的查询，如果观察到在特定的条件下hash索引可以提升速度，则建立hash索引，称之为自适应hash索引。

4. Log Buffer

Log Buffer：日志缓冲区，用来保存要写入到磁盘中的log日志数据（redo log 、undo log），默认大小为 16MB，日志缓冲区的日志会定期刷新到磁盘中。如果需要更新、插入或删除许多行的事务，增加日志缓冲区的大小可以节省磁盘 I/O。

参数:

innodb_log_buffer_size：缓冲区大小

innodb_flush_log_at_trx_commit：日志刷新到磁盘时机，取值主要包含以下三个：

1: 日志在每次事务提交时写入并刷新到磁盘，默认值。

0: 每秒将日志写入并刷新到磁盘一次。2: 日志在每次事务提交后写入，并每秒刷新到磁盘一次。

#### 8.1.2 磁盘结构

1. System Tablespace

系统表空间是更改缓冲区的存储区域。如果表是在系统表空间而不是每个表文件或通用表空间中创建的，它也可能包含表和索引数据。(在MySQL5.x版本中还包含InnoDB数据字典、undolog等)

参数：innodb_data_file_path

2. File-Per-Table Tablespaces

如果开启了innodb_file_per_table开关 ，则每个表的文件表空间包含单个InnoDB表的数据和索引 ，并存储在文件系统上的单个数据文件中。

开关参数：innodb_file_per_table ，该参数默认开启

我们每创建一个表，都会产生一个表空间文件，

3. General Tablespaces

通用表空间，需要通过 CREATE TABLESPACE 语法创建通用表空间，在创建表时，可以指定该表空间。

